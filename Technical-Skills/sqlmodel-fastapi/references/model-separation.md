# Model Separation Patterns

Complete guide for separating database models from API models in SQLModel.

## Why Separate Models?

Using the same model for database and API creates issues:

```python
# BAD: Single model for everything
class Task(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str
    created_at: datetime

# Problems:
# - Client can set id (should be auto-generated)
# - Client can set created_at (should be server-set)
# - Response includes internal fields
# - No control over validation per operation
```

**Model separation solves these problems:**
- Clients cannot set `id` or `created_at`
- Different validation for create vs update
- Control over response fields
- Type safety for different operations

## Four-Model Pattern

### TaskDB (Database Model)

Has `table=True` for SQLAlchemy. Contains ALL database fields:

```python
from sqlmodel import SQLModel, Field
from typing import Optional
from datetime import datetime, timezone

class TaskDB(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = None
    status: str = Field(default="pending")
    priority: int = Field(default=1)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
```

**Characteristics:**
- `table=True` creates database table
- All fields including `id` and timestamps
- Field constraints for database validation
- Default values for database

### TaskCreate (Create Request)

What clients provide when creating new items:

```python
class TaskCreate(SQLModel):
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = None
    status: str = Field(default="pending")
    priority: int = Field(default=1, ge=1, le=5)
```

**Characteristics:**
- No `table=True`
- No `id` (database generates)
- No `created_at` (server sets)
- No `updated_at` (server sets)
- Required fields for creation
- Default values for optional fields

### TaskUpdate (Update Request)

What clients provide when updating items:

```python
class TaskUpdate(SQLModel):
    title: Optional[str] = Field(default=None, min_length=1, max_length=200)
    description: Optional[str] = None
    status: Optional[str] = None
    priority: Optional[int] = Field(default=None, ge=1, le=5)
```

**Characteristics:**
- No `table=True`
- ALL fields optional
- No `id` (in URL path)
- No timestamps (server updates)
- Allows partial updates

### TaskPublic (Response Model)

What clients see in responses:

```python
class TaskPublic(SQLModel):
    id: int
    title: str
    description: Optional[str] = None
    status: str
    priority: int
    created_at: datetime
    updated_at: datetime
```

**Characteristics:**
- No `table=True`
- All fields required
- Includes computed or formatted fields
- Excludes internal fields (passwords, tokens)

## Conversion Patterns

### Create: TaskCreate -> TaskDB

```python
@app.post("/tasks", status_code=201, response_model=TaskPublic)
def create_task(task: TaskCreate, session: Session = Depends(get_session)):
    # Convert TaskCreate to TaskDB
    db_task = TaskDB.model_validate(task)
    # id and timestamps auto-generated by Field defaults
    session.add(db_task)
    session.commit()
    session.refresh(db_task)

    # Convert TaskDB to TaskPublic
    return TaskPublic.model_validate(db_task)
```

### Update: TaskUpdate -> TaskDB

```python
@app.put("/tasks/{task_id}", response_model=TaskPublic)
def update_task(
    task_id: int,
    task_update: TaskUpdate,
    session: Session = Depends(get_session)
):
    task = session.get(TaskDB, task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    # Only update provided fields
    update_data = task_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(task, key, value)

    # Update timestamp manually
    task.updated_at = datetime.now(timezone.utc)

    session.add(task)
    session.commit()
    session.refresh(task)

    return TaskPublic.model_validate(task)
```

### Response: TaskDB -> TaskPublic

```python
@app.get("/tasks/{task_id}", response_model=TaskPublic)
def get_task(task_id: int, session: Session = Depends(get_session)):
    task = session.get(TaskDB, task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    # Convert TaskDB to TaskPublic
    return TaskPublic.model_validate(task)
```

### List: List[TaskDB] -> List[TaskPublic]

```python
from typing import List

@app.get("/tasks", response_model=List[TaskPublic])
def list_tasks(session: Session = Depends(get_session)):
    tasks = session.exec(select(TaskDB)).all()

    # Convert list of TaskDB to list of TaskPublic
    return [TaskPublic.model_validate(task) for task in tasks]
```

## Advanced Patterns

### Extended Response Model

Include additional computed fields:

```python
class TaskPublicExtended(SQLModel):
    id: int
    title: str
    status: str
    created_at: datetime
    is_overdue: bool  # Computed field
    days_until_due: Optional[int]  # Computed field

@app.get("/tasks/{task_id}", response_model=TaskPublicExtended)
def get_task_extended(task_id: int, session: Session = Depends(get_session)):
    task = session.get(TaskDB, task_id)
    if not task:
        raise HTTPException(status_code=404)

    return TaskPublicExtended(
        id=task.id,
        title=task.title,
        status=task.status,
        created_at=task.created_at,
        is_overdue=task.due_date < datetime.now(timezone.utc),
        days_until_due=(task.due_date - datetime.now(timezone.utc)).days if task.due_date else None
    )
```

### Nested Models

```python
class ItemPublic(SQLModel):
    id: int
    name: str

class UserPublic(SQLModel):
    id: int
    username: str
    items: List[ItemPublic]  # Nested relationship
```

### Create with Relationships

```python
class TaskCreate(SQLModel):
    title: str
    assignee_id: int  # Foreign key

@app.post("/tasks")
def create_task(task: TaskCreate, session: Session = Depends(get_session)):
    # Validate assignee exists
    assignee = session.get(UserDB, task.assignee_id)
    if not assignee:
        raise HTTPException(status_code=404, detail="Assignee not found")

    db_task = TaskDB.model_validate(task)
    session.add(db_task)
    session.commit()
    session.refresh(db_task)

    return TaskPublic.model_validate(db_task)
```

### Protected Fields

Exclude sensitive fields from responses:

```python
class UserDB(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    username: str
    hashed_password: str  # Never expose
    is_active: bool = True

class UserCreate(SQLModel):
    username: str
    password: str  # Plain text input

class UserPublic(SQLModel):
    id: int
    username: str
    is_active: bool
    # No hashed_password
```

## Field Validation Patterns

### String Validation

```python
class TaskCreate(SQLModel):
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = Field(max_length=5000)
```

### Numeric Validation

```python
class TaskCreate(SQLModel):
    priority: int = Field(default=1, ge=1, le=5)
    progress: int = Field(default=0, ge=0, le=100)
    price: float = Field(gt=0)
```

### Email Validation

```python
from pydantic import EmailStr

class UserCreate(SQLModel):
    email: EmailStr
```

### Enum Validation

```python
from enum import Enum

class TaskStatus(str, Enum):
    pending = "pending"
    in_progress = "in_progress"
    completed = "completed"

class TaskCreate(SQLModel):
    status: TaskStatus = TaskStatus.pending
```

### Custom Validators

```python
from pydantic import field_validator

class TaskCreate(SQLModel):
    title: str

    @field_validator('title')
    @classmethod
    def title_must_not_be_blank(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Title cannot be blank')
        return v
```

## Common Pitfalls

### Forgetting exclude_unset

```python
# BAD: Overwrites all fields with None
update_data = task_update.model_dump()
for key, value in update_data.items():
    setattr(task, key, value)  # Sets all fields, even None

# GOOD: Only updates provided fields
update_data = task_update.model_dump(exclude_unset=True)
for key, value in update_data.items():
    setattr(task, key, value)
```

### Including Auto Fields in Create

```python
# BAD: Client can set id
class TaskCreate(SQLModel):
    id: Optional[int]  # Don't include
    title: str

# GOOD: No id in create model
class TaskCreate(SQLModel):
    title: str
```

### Wrong Conversion

```python
# BAD: Direct assignment doesn't validate
db_task = TaskDB(**task.dict())

# GOOD: Use model_validate for conversion
db_task = TaskDB.model_validate(task)
```

## Best Practices

1. **Always separate models** - Never use DB model for API
2. **Use model_validate** - For converting between models
3. **Use exclude_unset** - For partial updates
4. **Validate inputs** - Use Field() constraints
5. **Hide sensitive fields** - Exclude from response models
6. **Document transformations** - Comments explain conversions
7. **Test conversions** - Unit tests for model transformations
